package debext

import (
	"bytes"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/aptly-dev/aptly/deb"
	"github.com/aptly-dev/aptly/utils"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGeneratePackageIndex(t *testing.T) {
	testdataDir := filepath.Join("testdata", "files-stripped-cleared")

	t.Run("Sources", func(t *testing.T) {
		dscFiles, err := filepath.Glob(filepath.Join(testdataDir, "*.dsc"))
		require.NoError(t, err)
		sources := deb.NewPackageList()

		for _, dscFile := range dscFiles {
			verifier := testVerifier()
			tempSrc, err := ParseSource(dscFile, verifier, "")
			require.NoError(t, err)
			poolPath := GetPoolPath("main", tempSrc.Name)
			src, err := ParseSource(dscFile, verifier, poolPath)
			require.NoError(t, err)

			// Complete checksums for referenced source files
			files := src.Files()
			dscDir := filepath.Dir(dscFile)
			for i := range files {
				if !files[i].Checksums.Complete() {
					fullPath := filepath.Join(dscDir, files[i].Filename)
					checksums, err := utils.ChecksumsForFile(fullPath)
					require.NoError(t, err)
					files[i].Checksums = checksums
				}
			}
			src.UpdateFiles(files)
			err = sources.Add(src)
			require.NoError(t, err)
		}

		var output bytes.Buffer
		err = GeneratePackageIndex(&output, sources, true)
		assert.NoError(t, err)

		expected, err := os.ReadFile(filepath.Join("testdata", "Sources"))
		require.NoError(t, err)
		assert.Equal(t, string(expected), output.String())
	})

	t.Run("Packages", func(t *testing.T) {
		debFiles, err := filepath.Glob(filepath.Join(testdataDir, "*.deb"))
		require.NoError(t, err)
		packages := deb.NewPackageList()

		for _, debFile := range debFiles {
			tempPkg, err := ParseBinary(debFile, "")
			require.NoError(t, err)
			poolPath := GetPoolPath("main", tempPkg.Name)
			pkg, err := ParseBinary(debFile, poolPath)
			require.NoError(t, err)
			err = packages.Add(pkg)
			require.NoError(t, err)
		}

		var output bytes.Buffer
		err = GeneratePackageIndex(&output, packages, false)
		assert.NoError(t, err)

		expected, err := os.ReadFile(filepath.Join("testdata", "Packages"))
		require.NoError(t, err)
		assert.Equal(t, string(expected), output.String())
	})
}

func TestGenerateRelease(t *testing.T) {
	packagesChecksums, err := utils.ChecksumsForFile("testdata/Packages")
	require.NoError(t, err)
	sourcesChecksums, err := utils.ChecksumsForFile("testdata/Sources")
	require.NoError(t, err)

	config := Release{
		Origin:        "vaultwarden noble",
		Label:         "vaultwarden noble",
		Suite:         "noble",
		Codename:      "noble",
		Date:          time.Date(2025, 12, 7, 11, 59, 9, 0, time.UTC),
		Architectures: []string{"amd64"},
		Components:    []string{"main"},
		Description:   "Generated by aptly",
		Files: map[string]utils.ChecksumInfo{
			"main/binary-amd64/Packages": packagesChecksums,
			"main/source/Sources":        sourcesChecksums,
		},
	}

	var output bytes.Buffer
	err = GenerateRelease(&output, config)
	assert.NoError(t, err)

	expected, err := os.ReadFile("testdata/Release")
	require.NoError(t, err)
	assert.Equal(t, string(expected), output.String())
}

func TestParseRelease(t *testing.T) {
	releaseData, err := os.ReadFile("testdata/Release")
	require.NoError(t, err)

	reader := deb.NewControlFileReader(strings.NewReader(string(releaseData)), false, false)
	stanza, err := reader.ReadStanza()
	require.NoError(t, err)

	assert.Equal(t, "vaultwarden noble", stanza["Origin"])
	assert.Equal(t, "noble", stanza["Suite"])
	assert.Contains(t, stanza["Architectures"], "amd64")
	assert.NotEmpty(t, stanza["SHA256"])
}

func TestParsePackageIndex(t *testing.T) {
	t.Run("Packages", func(t *testing.T) {
		packages, err := ParsePackageIndex("testdata/Packages", false)
		assert.NoError(t, err)
		assert.Len(t, packages, 6)
		assert.NotEmpty(t, packages[0].Name)
		assert.False(t, packages[0].IsSource)
	})

	t.Run("Sources", func(t *testing.T) {
		sources, err := ParsePackageIndex("testdata/Sources", true)
		assert.NoError(t, err)
		assert.Len(t, sources, 6)
		assert.True(t, sources[0].IsSource)
	})
}

func TestParseBinary(t *testing.T) {
	debFiles, err := filepath.Glob("testdata/files-stripped-cleared/*.deb")
	require.NoError(t, err)
	require.NotEmpty(t, debFiles)

	tempPkg, err := ParseBinary(debFiles[0], "")
	require.NoError(t, err)
	poolPath := GetPoolPath("main", tempPkg.Name)
	pkg, err := ParseBinary(debFiles[0], poolPath)

	assert.NoError(t, err)
	assert.NotEmpty(t, pkg.Name)
	assert.False(t, pkg.IsSource)
	assert.True(t, pkg.Files()[0].Checksums.Complete())
	assert.Contains(t, pkg.Files()[0].DownloadURL(), poolPath)
}

func TestParseSource(t *testing.T) {
	dscFiles, err := filepath.Glob("testdata/files-stripped-cleared/*.dsc")
	require.NoError(t, err)
	require.NotEmpty(t, dscFiles)

	verifier := testVerifier()
	poolPath := "pool/main/v/vaultwarden"
	pkg, err := ParseSource(dscFiles[0], verifier, poolPath)

	assert.NoError(t, err)
	assert.NotEmpty(t, pkg.Name)
	assert.True(t, pkg.IsSource)
	assert.NotEmpty(t, pkg.Files())
	assert.Equal(t, poolPath, pkg.Extra()["Directory"])
}

func TestParseChanges(t *testing.T) {
	changesFiles, err := filepath.Glob("testdata/files-stripped-cleared/*.changes")
	require.NoError(t, err)
	require.NotEmpty(t, changesFiles)

	verifier := testVerifier()
	changes, err := ParseChanges(changesFiles[0], verifier)

	assert.NoError(t, err)
	assert.NotEmpty(t, changes.Changes)
	assert.NotEmpty(t, changes.Files)
	assert.NotEmpty(t, changes.Source)
}

func TestGetPoolPath(t *testing.T) {
	assert.Equal(t, "pool/main/v/vaultwarden", GetPoolPath("main", "vaultwarden"))
	assert.Equal(t, "pool/main/libc/libc6", GetPoolPath("main", "libc6"))
	assert.Equal(t, "pool/contrib/p/python", GetPoolPath("contrib", "python"))
}

func TestIsDebugPackage(t *testing.T) {
	assert.True(t, IsDebugByName("package-dbgsym"))
	assert.False(t, IsDebugByName("package"))
	assert.True(t, IsDebugPackageByFilename("package-dbgsym_1.0.deb"))
	assert.True(t, IsDebugPackageByFilename("package_1.0.ddeb"))
	assert.False(t, IsDebugPackageByFilename("package_1.0.deb"))
}
